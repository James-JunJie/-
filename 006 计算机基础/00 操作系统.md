#操作系统的基本特征？

###1.并发

并行性和并发性是既相似又有区别的两个概念。

并行性是指两个或多个事件在同一时刻发生；

而并发性是指两个或多个事件在同一时间间隔内发生。

在单处理机上，并发是**宏观并行，微观串行。**

###2.共享

共享是指系统中的资源可以被多个并发进程共同使用。

两种共享：

* 互斥共享:  打印机..

* 同时共享:  磁盘

###3.虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。**利用多道程序设计技术(程序的交替运行)，让每个用户都觉得有一个计算机专门为他服务。**

主要有两种虚拟技术：时间复用技术和空间复用技术。

* **时间复用**：指**多个进程能在同一个处理器上并发执行**，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

* **空分复用**：将物理内存抽象为地址空间，每个进程都有各自的地址空间。当需要一个地址空间时，如果没有那就执行页面置换算法。

###4.异步

异步指**进程不是一次性执行完毕**，而是走走停停，以不可知的速度向前推进。但只要运行的环境相同，OS需要保证程序运行的结果也要相同。

##处理机的状态

4个处理机特权级别（R0，R1，R2和R3）

R0：运行操作系统核心代码

R3：运行各种用户程序

指令分为 特权指令和非特权指令

## 内核态

内核态：一般指**操作系统管理程序运行时的状**态，具有较高的特权级别。特权指令

## 用户态

用户态：一般指**用户程序运行时的状态**，具有较低的特权级别。非特权指令

#中断和异常

### 什么是中断？

指处理机对**系统中或系统外发生的异步事件的响应**。 中断技术是向处理机报告“设备已完成操作”的一种手段，防止处理器去轮询事件。

中断事件：引起中断的那些事件称为或中断源

中断请求：中断源向处理机发出的请求信号，

中断处理程序**：处理中断事件的那段程序称为**。

中断断点：发生中断时正在执行的程序的暂停点称为

中断响应，处理机暂停当前程序转而处理中断的过程

中断返回：中断处理结束之后恢复原来程序的执行 

###中断具有以下作用：

* 能充分发挥处理机的使用效率 。可以免除处理机不断地轮询和等待，

###中断依据被激发的手段可以分为强迫性中断和自愿性中断：

* **强迫性中断事件**是正在运行的程序所不期望发生的，它们出现的随机性比较强。强迫性中断包括：时钟中断、I/O中断、控制台中断、硬件故障以及程序性中断（例如非法指令）等。
* **自愿性中断**是正在运行的程序故意安排执行的，通常由**访管指令**引起，目的是要求操作系统提供系统服务。这一类中断发生的时间以及位置具有确定性。

###中断依据中断事件的发生和处理是否异步分：

* **同步中断**(异常)：异常的发生则是**当前程序的编码和逻辑激发的，属于“内因”性质。**
* **异步中断**(中断):异步中断的发生一般是**由对当前程序而言的外部事件激发的**，属于外源性质，不可预测

### 中断分类

* 程序中断。 **指令执行结果产生**，例如算术溢出、被零除、试图执行非法指令等。

* 时钟中断。由处理机内部的计时器产生，允许操作系统以一定规律执行函数。

* **I/O中断**。由I/O控制器产生，用于通知一个**I/O操作的正常完成或者发生的错误**。

* 硬件失效中断。由掉电、存储器校验错等硬件故障引起。
* **访管中断**。用户程序在运行中调用操作系统函数，引起访管中断，并调用操作系统相应的功能模块为其服务。

### 如果中断发生了，处理器为我们做了什么？

* 处理器接受到一个中断信号
* 处理器完成当前指令后响应中断
* 保存中断断点(程序的上下文)
* 执行中断处理程序
* 执行结束，恢复处理器状态。

###什么是中断处理程序?

在响应一个特定中断的时候，内核会**执行一个函数**，该函数叫做**中断处理程序**。产生中断的每个设备都有一个相应的中断处理程序，如果一个设备可以产生多种不同的中断，那么该设备就可以对应多个中断处理程序。一个设备的中断处理程序是它设备驱动程序的一部分。

###什么是异常?

**同步中断**又称为异常（exception），**异步中断**则被称为**中断（interrupt）**。我们通常讲的中断指的都是异步中断。
1.中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。
2.异常可分为故障（fault）、陷阱（trap）、终止（abort）三类。

#进程

**1、进程**

* 进程是程序的一次执行

* 进程是**资源分配的基本单位**。 

**2、线程**

线程是**独立调度的基本单位**。线程可以共享进程的资源。

##进程的几种状态

* 运行
* 活动就绪

* 静止就绪

* 活动阻塞
* 静止阻塞

5态

![image-20210910155058976](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210910155058976.png)

## 进程的调度

* 高级调度（作业调度）: 将作业调入内存，**创建进程，进入就绪队列。**
* 低级调度(进程调度)：分配cpu使用权给进程，就绪--获取cpu--->运行
* 中级调度存和外出的进程对换，解决内存紧张问题。

![image-20210910155849066](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210910155849066.png)

###调度方式：

* 非剥夺
  * 先来先服务
* 剥夺
  * 优先权原则
  * 短进程优先原则
  * 时间片原则

###进程调度5算法

* **先来先服务调度算法（FCFS**）：**根据进程到达的先后顺序执行进程**，**不考虑等待时间和执行时间**，**会产生饥饿现象**。属于非抢占式调度，
  * 优点是公平，实现简单
  * **缺点是不利于短作业**。
* **时间片轮转调度算法（RR）**：给**每个进程固定的执行时间**，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。
  * 优点：兼顾长短作业
  * 缺点：平均等待时间较长，上下文切换较费时。适用于分时系统。
* **优先级调度**算法（HPF）：在进程等待队列中选择**优先级最高的来执行**。
* **多级反馈队列**调度算法：将**时间片轮转**与**优先级调度相**结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。
  * 优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。
  * 高优先级队列，时间片少。
* **高响应比优先**调度算法：根据“`响应比=（进程执行时间+进程等待时间）/  进程执行时间`”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足短任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。
  * 优点是兼顾长短作业
  * 缺点是计算响应比开销大，适用于批处理系统。

## 进程同步

（1）为什么要进程同步

多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。

###同步机制需要遵循的原则：

1. **空闲让进**：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请
2. **忙则等待**：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问
3. **有限等待**：对要求访问临界资源的进程，应保证该**进程能在有效的时间内进入自己的临界区**，以免陷入“死等”状态。
4. **让权等待**：当进程无法进入临界区的时候，需要**释放处理机，以免陷入"忙等"**

PV操作。

### 生产者消费者

mutex：公用缓冲池中有n个缓冲区，可利用互斥信号量mutex使诸进程实现**对缓冲池的互斥使用**

empty 记录**空缓冲区的数量**，当 empty 不为 0 时，生产者才可以放入物品

full 记录**满缓冲区的数量**。当 full 信号量不为 0 时，消费者才可以取走物品。

```java
 2typedef int semaphore;
 3semaphore mutex = 1;
 4semaphore empty = N;
 5semaphore full = 0;
 6
 7void producer() {
 8    while(TRUE) {
 9        int item = produce_item();
10        down(&empty);
11        down(&mutex);
12        insert_item(item);
13        up(&mutex);
14        up(&full);
15    }
16}
17
18void consumer() {
19    while(TRUE) {
20        down(&full);
21        down(&mutex);
22        int item = remove_item();
23        consume_item(item);
24        up(&mutex);
25        up(&empty);
26    }
27}
```

###哲学家进餐

> 有5个哲学家，他们的生活方式是交替地进行思考和进餐；哲学家们共用一张圆桌，分别坐在周围的5张椅子上；在圆桌上有5个碗和5支筷子，平时哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐；进餐完毕后，放下筷子继续思考。

####3个解决办法

* 仅当哲学家的**左、右两支筷子均可用时才允许他拿起筷子进餐**。

* **至多只允许4个哲学家同时进餐**，以保证至少有一个哲学家能够进餐，最终总会释放出他所使用过的两支筷子，从而可使更多的哲学家进餐。

* 规定**奇数号哲学家先拿他左边的筷子，然后再去拿他右边的筷子**；而偶数号哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即5个哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐。

![image-20210910163553874](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210910163553874.png)

coding:

![image-20210910163716951](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210910163716951.png)

### 进程7种通信方式

* **管道pipe**：管道是一种**半双工的通信方式**，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指**父子进程关系。**
* **命名管道FIFO**：有名管道也是**半双工的通信方式**，但是**它允许无亲缘关系进程间的通信**。
* **消息队列MQ**：消息队列是由**消息的链表**，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、 **缓冲区大小**受限等缺点。
* **共享内存SharedMemory**： **共享内存由一个进程创建，但多个进程都可以访问**。 **效率高，减少拷贝。**
* **信号量Semaphore**： 控制多个进程对共享资源的访问。 **一种锁机制 ，进程的同步手段。**
* **套接字Socket**：套解字，用于**不同计算机间的进程通信**。
* **信号 ( sinal )** ： 信号是一种比较复杂的通信方式，用于**通知接收进程某个事件已经发生。**

#### 管道

管道的实质是**一个内核缓冲区**，进程**以先进先出的方式**从缓冲区存取数据。**是一个循环队列**。

因为他是一个**先进先出，所以是半双工的。**

####消息队列

消息队列，就是一个消息的**链表**，是一系列保存在内核中消息的列表。

####共享内存

共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的**进程映射至自身的地址空间中，**一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。

采用共享内存，效率高，减少拷贝次数。

![在这里插入图片描述](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/2019042614103483.png)

![在这里插入图片描述](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/20190426141107202.png)

#### 信号量

 信号量用于实现**进程间的互斥与同步**，而不是用于存储进程间通信数据。类似pv操作。

## 死锁

#内存



##逻辑地址和物理地址

> 用户只在各自的逻辑地址空间编写程序，不必过问物理空间和物理地址的细节，地址的转换由操作系统自动完成

##程序运行：

因为cpu是按物理地址进行的，所以装入时涉及地址转换。

![image-20211101161839978](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101161839978.png)





##链接

* **静态链接**: 将各个目标模块及它们所需要的库函数，**连接成一个完整的装入模块**
* **动态链接**：边装入，边链接。即在装入一个目标模块时，如果发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，进行连接
* **运行时动态连接**:程序执行中需要该模块是，才对它进行链接。未被执行模块，不会调入内存。

##装入

1）**绝对装入方式**。在绝对装入方式中，逻辑地址转换成物理地址的过程发生在**程序编译或汇编时**。 程序必须装入内存的固定位置 。适合单道操作系统

2）**静态重定位装入方式**。在重定位装入方式中，逻辑地址转换成物理地址的过程发生在程序**装入内存时进行**。 静态重定位不允许**程序在内存中移动位置。**

3）**动态运行时装入方式**。在动态运行时装入方式中，逻辑地址转换成物理地址的过程推迟到**程序真正执行时**。它在内存中的位置可能经常要改变，此时就应采用动态运行时装入方式。

重定位寄存器：转换结构

![image-20211101162604609](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101162604609.png)

## 覆盖和交换

> 覆盖与交换是解决大程序与小内存矛盾的两种存储管理技术，它们实质上对内存进行了逻辑扩充

###覆盖技术

一个程序的覆盖结构要求编程人员事先声明。（不在使用）

固定区+覆盖区

![image-20211101171923951](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101171923951.png)

### 交换技术

中级调度：进程在内存与磁盘间的动态调度。

挂起状态：暂时换出外村等待的进程。**(就绪挂起，阻塞挂起)**



##单一连续分配和分区分配

###单一连续分配

单一连续分配是最简单的一种存储管理方式，但**只能用于单用户、单任务的操作系统中。**

优点：实现简单，回收算法简单

缺点：有内部碎片，内存利用率低。



![image-20211101153728128](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101153728128.png)

### 分区分配

目的：为了**适应多道程序设计技术**而产生的最简单的存储管理。它把内存划分成若干个连续的区域，每个用户程序占有一个。

#### 固定分区:

> 预先分为大小不等的连续区域

* 相等大小分区
* 不相等大小分区

优点：简单易行(对于程序的大小预先可以知道的专用系统比较实用 )

缺点：产生内存碎片

##### 固定分区分配表

![image-20211101154739763](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101154739763.png)

###动态分区:

> 系统并不预先划分内存空间，而在程序装入时根据程序的实际需要动态地划分内存空间

在程序装入时根据程序的实际需要动态地划分内存空间。

####使用什么数据结构记录内存?

**1.空闲分区表：**

 ![image-20211101155539293](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101155539293.png)

**2.空闲分区链：**

> 使用双向链表。

![image-20211101155603912](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101155603912.png)

####分配算法？

①**首次适应算法**：分配首次找到内存空间适合。

②**循环首次适应算法**：

③**最佳适应算法**：既能**满足要求、又是最小的空闲分区分配给程序**。形成很多外部碎片。

④**最差适应算法**：总是找到一个满足程序长度要求的**最大空闲分区进行分配**，**以便使剩下的空闲区不至于太小而形成内存碎片**。

####分区的分配和回收？

如果回收后，有相邻的空闲分区，应该进行合并。

动态分区没有内部碎片，**但有外部碎片**

**内部碎片**：分配给某进程的内存区域中，有部分内存没有利用上。

**外部碎片**：内存中的某些空闲分区太小而难以利用

> 下图：进程1无法利用空闲分区。

![image-20211101160459950](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101160459950.png)

#### 如何解决外部碎片？--紧凑技术

解释：原来分散的**多个小分区便拼接成一个大分区**，从而就可以把程序装入运行

缺点：开销很大，必须进行重定位

![image-20211101160931503](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20211101160931503.png)

##非连续分配管理方式？

度为单位进行等量划分。把进程的逻辑空间分成一些大小相同的片段称为页面或页（Page）

###分页存储管理



页帧：

（1）基本分页存储管理中不具备页面置换功能，因此需要整个程序的所有页面都装入内存之后才可以运行。

（2）需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。

（3）由于页表也是存储在内存中的，因此内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。

（4）为了减少两次访问内存导致的效率影响，分页管理中引入了快表，当要访问内存数据的时候，首先将页号在快表中查询，如果在快表中，直接读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。

（5）在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。

页表：页表存储在内存中

快表：高速速缓冲存储器



###分段存储管理





### 段页式存储方式









## 虚拟内存

