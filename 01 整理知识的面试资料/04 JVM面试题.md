##1. 内存模型以及分区?

简述Java的对象结构





## JVM的永久代中会发生垃圾回收么

jdk8 方法区使用永久代实现，这样是为了省去编写专门的内存管理代码工作。

jdk8 使用元空间。永久代也并非永久存在。

主要回收目标： 

* 常量池的回收
* 类的卸载

1、java中会存在内存泄漏吗，请简单描述。

2、64 位 JVM 中，int 的长度是多数？

3、Serial 与 Parallel GC 之间的不同之处？

4、32 位和 64 位的 JVM，int 类型变量的长度是多数？

5、Java 中 WeakReference 与 SoftReference 的区别？

6、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用

7、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？

8、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

- 9、JRE、JDK、JVM 及 JIT 之间有什么不同？
- 10、解释 Java 堆空间及 GC？
- 11、JVM 内存区域
- 12、程序计数器(线程私有)
- 13、虚拟机栈(线程私有)
- 14、本地方法区(线程私有)
- 15、你能保证 GC 执行吗？
- 16、怎么获取 Java 程序使用的内存？堆使用的百分比？
- 17、Java 中堆和栈有什么区别？
- 18、描述一下 JVM 加载 class 文件的原理机制
- 19、GC 是什么？为什么要有 GC？
- 20、堆（Heap-线程共享） -运行时数据区
- 21、方法区/永久代（线程共享）
- 22、JVM 运行时内存
- 23、新生代
- 24、老年代
- 25、永久代
- 26、JAVA8 与元数据
- 27、引用计数法
- 28、可达性分析
- 29、标记清除算法（ Mark-Sweep）
- 30、复制算法（copying）
- 31、标记整理算法(Mark-Compact)
- 32、分代收集算法
- 33、新生代与复制算法
- 34、老年代与标记复制算法
- 35、JAVA 强引用
- 36、JAVA软引用
- 37、JAVA弱引用
- 38、JAVA虚引用
- 39、分代收集算法
- 40、在新生代-复制算法
- 41、在老年代-标记整理算法
- 42、分区收集算法
- 43、GC 垃圾收集器
- 44、Serial 垃圾收集器（单线程、 复制算法）
- 45、ParNew 垃圾收集器（Serial+多线程）
- 46、Parallel Scavenge 收集器（多线程复制算法、高效）
- 57、Serial Old 收集器（单线程标记整理算法 ）
- 58、Parallel Old 收集器（多线程标记整理算法）
- 59、CMS 收集器（多线程标记清除算法）
- 60、G1 收集器
- 61、JVM 类加载机制
- 62、类加载器
- 63、双亲委派
- 64、OSGI（ 动态模型系统）
- 65、动态改变构造
- 66、模块化编程与热插拔
- 67、JVM内存模型
- 68、栈
- 69、本地方法栈
- 70、程序计数器
- 71、堆
- 72、方法区
- 73、分代回收
- 74、堆和栈的区别
- 75、什么时候会触发FullGC
- 76、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
- 77、对象分配规则
- 78、描述一下JVM加载class文件的原理机制？
- 79、Java对象创建过程
- 81、如何判断对象可以被回收
- 83、垃圾收集算法
- 84、调优命令有哪些？
- 85、调优工具
- 86、Minor GC与Full GC分别在什么时候发生？
- 87、你知道哪些JVM性能调优