#数据库基础知识

##1.什么是数据库？

数据库是数据管理的有效技术，是由一批数据构成的有序集，数据被存放在结构化的数据表里。

mysql: Oracle旗下的一个**关系型数据库**管理系统。

##2.数据库和文件系统的区别

**其区别在于：**

(1) 文件系统用文件将数据**长期保存在外存上**，

​    数据库系统**用数据库统一存储数据**。

(2) 文件系统用**操作系统中的存取方法对数据进行管理**，

  数据库系统用**DBMS统一管理和控制数据**。

(3)文件系统实现以**文件为单位的数据共享**，

数据库系统实现以**记录和字段为单位的数据共享**

## 数据库三大范式是什么

第一范式：**每个列都不可以再拆分**。(属性不可分) 属性皆为原子值！

第二范式：1NF基础上，非主属性**不存在部分函数依赖**。**非主键列完全依赖于主键**，**而不能是依赖于主键的一部分。**

第三范式：2NF基础上，非主属性**不存在传递依赖**。**非主键列只依赖于主键，不依赖于其他非主键。**

BCNF:  **消除主属性对候选键的传递依赖**

尽量遵守三范式

> https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html

## 概念

超码(键)：唯一标识元组,且**可能存在冗余属性**

候选键：无冗余属性。(多个)
主键：从候选键选出一个
外键：其他关系的主键
主属性：**包含在一个候选键中的属性**。

##视图

视图是一种基于数据表的一种**虚表**，**视图就是基于查询的一种虚表，(视图可以将查询出来的数据进行封装)**

- 视图是**一种虚表**
- 视图建立在**已有表的基础上**, 视图赖以建立的这些表称为基表
- **向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句**
- 视图没有**存储真正的数据**，**真正的数据还是存储在基表中**
- 一个基表可以有0个或多个视图

## Mysql使用



## SQL

### Order by

ORDER BY *column_name1*,*column_name2* ASC|DESC;    ASC:升序

先根据column_name1排序，如果相等则使用column_name2

### group by

group by与order by很类似，其实质是**先排序后分组**，**遵照索引创建顺序的最左前缀法则。**

###Limit

limit n, m; 

* n:偏移量
* m:返回记录行的最大数目

ex:

查找第三行：limit 2,1;

检索记录行 96-last:  LIMIT 95,-1; 

LIMIT n 等价于 LIMIT 0,n。 

###join

```sql
FROM Websites
INNER JOIN access_log
ON Websites.id=access_log.site_id;
```

- **INNER JOIN**：如果表中有**至少一个匹配**，则返回行
- **LEFT JOIN**：即使右表中没有匹配，也从**左表返回所有的行**
- **RIGHT JOIN**：即使左表中没有匹配，也从**右表返回所有的行**
- **FULL JOIN**：只要其中**一个表中存在匹配**，则返回行

### Having

在 SQL 中增加 HAVING 子句原因是，**WHERE 关键字无法与聚合函数**一起使用。

```sql
GROUP BY column_name
HAVING  SUM(column_name) > value;
```

###exsits

`select * from A where exists (select 1 from B where B.id = A.id)`

将主查询A的数据，放到子查询B中做条件验证，根据验证结果（true或false）来决定主查询的数据是否保留

### in

`select * from A where id in (select id from B)`

当B表的数据集小于A表的数据集时,in优于exists



#索引

## 什么是索引?

索引: 是一种数据结构,它能够高效的查询，更新数据库中的数据。索引的实现通常使用B+树。

##索引是个什么样的数据结构呢?

* Hash索引： **快速精准的查询**，但**不支持范围查询**
* 二叉树：容易形成斜树
* 平衡二叉树：树的高度太高，I\O次数多。
* B树 ： 
* B+树 ：

![image-20210903194724661](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210903194724661.png)

###索引中的B树

* **叶节点具有相同的深度**，**叶节点的指针为空**
* 所有**索引元素不重复**
* 节点中的数据索引**从左到右递增排列**

![image-20210903195649587](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210903195649587.png)

###索引中的B+树

* **非叶子节点不存储data**，只存储**索引(冗余)**，可以放更多的索引，高度相对B树低
* **叶子节点包含所有索引**字段，存储值。
* **叶子节点用双指针连接**，提高区间访问的性能.

![image-20210903195653206](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210903195653206.png)

## 一个B+树最多有节点？

默认页 16KB  所以一个节点也是16KB ：   16KB/(8+6)B = 1170  ; 1170 * 1170 *16 = **2千多万**



## 什么是平衡二叉树，B树，B+树，红黑树？





##Hash索引和B+树索引有什么区别或者说优劣呢?

Hash索引：可以O(1)找到数据。但不支持范围查找

B+树：可以支持返回查找。



##MySQL存储引擎MyISAM与InnoDB区别

|            | MyISAM                                             | Innodb                                 |
| ---------- | -------------------------------------------------- | -------------------------------------- |
| **存储**   | 非聚集索引：MyISAM:**MYI(索引表**),**MYD(数据表)** | 聚集索引：将索引与数据放在一起(InnoDB) |
| **事务**   | 不支持                                             | **支持**                               |
| 锁         | 表锁                                               | **行锁**、表锁                         |
| **外键**   | 不支持                                             | **支持**                               |
| Crash-safe | 没有crash-safe能力                                 | redo log 是 InnoDB 引擎特有的日志.     |
| 哈希索引   | 不支持                                             | 支持                                   |

## 主键索引和非主键索引

主键索引：data存储整个元组

非主键索引： data存储的是id

>  主键索引 age , name

![image-20210903201518738](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210903201518738.png)

## 为什么非主键索引 叶子节点存储的是 主键id？(一致性和节省存储空间)

如果data存储的是所有列，那么插入的时候，会**维护多个索引表**，这样会有**数据一致性**的考虑。

##为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？

* **整型:** 索引会比较大小，**整型容易比较大小** , 同时相比uuid，能节省空间。
* **自增**主键：自增每次插入时，才能向后插入，减少**页分裂**和**自平衡**(满足B树的平衡)

##说说InnoDB的索引原理



## 联合索引是什么？为什么需要注意联合索引中的顺序？

联合索引：**多个字段同时建立一个索引**。

假设现在建立了"name，age，school"的联合索引

联合索引排序规则: 

* 先按照name排序，如果name相同，则按照age排序

* 如果age的值也相等，则按照school进行排序。

具体原因为:B+树是从左到右递增的。

>  主键联合索引

![image-20210903201939499](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210903201939499.png)

##覆盖索引：

查询的所有字段，是在key里面。不用去查询data(紫色部分)，如果非主键索引，会回表操作。

## 字段为什么要求定义为not null?

方面索引。

#索引优化

使用explain工具，Extra列中sing index：使用覆盖索引

###1.最左匹配原则：

如果索引了多列，要遵守最左前缀法则。指的是**查询**从索引的**最左前列开始**并且**不跳过索引中的列**。

 索引顺序： `name`, `age`, `position`

`EXPLAIN SELECT * FROM employees WHERE age = 22 AND position ='manager'; `不走索引，因为跳过了name

`EXPLAIN SELECT * FROM employees WHERE age = 22 AND name = 'LiLei';`	内部优化，name,age走索引

###2.在索引列上做操作（计算、函数、（自动or手动）类型转换)

mysql优化，如果有函数直接不走索引。

默认使用**函数**(int-->String),所以索引失效！

###3.存储引擎不能使用索引中范围条件右边的列

`EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age > 22 AND position ='manager';`

position不做索引：age>22范围查找后，第三字段的值可能在最后，第三个值一 一比对等同于全表扫描

<img src="https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210903210240611.png" alt="image-20210903210240611" style="zoom:80%;" />



* 4.**减少select *语句**，**尽量使用覆盖索引**（只访问索引的查询（索引列包含查询列））

* 5.mysql在**使用不等于（！=或者<>）**的时候无法使用索引会导致全表扫描
* 6.**like以通配符开头**（'$abc...'）mysql索引失效**会变成**全表扫描操作
  *  'azz%':  通配符在后可以走索引
* 7**.is null,is not null 也无法使用索引**
* 8.**字符串不加单引号索引失效**
  * mysql会默认使用**函数**(int-->String),所以索引失效！ `EXPLAIN SELECT * FROM employees WHERE name = 1000;`
* 9.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化
* 10.范围查询优化
* 11.Order by与Group by优化：根据索引选择是用索引还是文件排序。



## 为什么是用覆盖索引?

非主键索引顺序： `name`, `age`, `position`

`EXPLAIN select * from employees where name > 'Jun';`

sql分析：全表扫描； **走索引，需要根据id进行回表操作**，**成本比全表扫描高。**

`EXPLAIN select name,age,position from employees where name > 'a' ;`

sql分析：走索引。**使用覆盖索引，无需回表，效率高。**

分析是否走索引：**使用trace工具用法**



##文件排序(Using filesort)

使用Order by `字段`，会造成文件排序和索引排序 

* 单路排序：是**一次性取出满足条件行的所有字段**，然后在sort buffer中进行排序

* 双路排序（又叫**回表排序模式**)：
  * 首先根据相应的**条件取出相应的排序字段**和**索引ID**
  * 然后在 sort buffer 中进行排序
  * 拍完序，回表找到其他字段；

##超大分页怎么处理?

sql1: `SELECT * from employees limit 1000,10;`：

实际扫描了1000行，之后取出

sql2: `select * from employees where id > 20 limit 5;` 

条件**主键自增且连续**，走索引，如果id不连续则会出错。

### 生产中优化

1使用覆盖索引：

`select id from employees ORDER BY name limit 20,5;`

**2.回表关联查询：**

`select * from employees e inner join (select id from employees order by name limit 90000,5) b on e.id = b.id;`

先查询分页的id(使用了覆盖索引)，再根据id查询字段数据。

####为什么效率高？

因为：回表的数量少(大概就10条，20条)

##join关联查询优化

t2 小表  t1大表

### 嵌套循环连接 Nested-Loop Join(NLJ) 算法

` EXPLAIN select*from t2 inner join t1 on t1.a= t2.a; `

一次一行循环地从**第一张表（称为驱动表）中读取行**，在这行**数据中取到关联字段**，根据关联字段在另**一张表（被驱动表）里取出满足条件的行**，然后取出两张表的结果合集。、

**上面sql的大致流程如下：**

1. 从表 **t2 小表中读取一行数据**； //共计 100 次
2. 从第 1 步的数据中，取出**关联字段 a，到表 t1大表中查找**； //走索引共计100次
3. 取出表 t1 中满足条件的行，跟 t2 中获取到的**结果合并**，作为结果返回给客户端；
4. 重复上面 3 步。

#####为什么需要小表驱动大表呢？为什么从t2表中取数据去t1中走索引比较呢？

 尽量让大表t1走索引

总次数:200行 :读取 t2 表的所有数据(扫描100行)，根据t2表中a的值---->t1表索引扫描(一次扫描走索引一次，总共 t1 表也扫描了100行)

缺点：磁盘I\O，耗费时间。

###基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法

` EXPLAIN select*from t2 inner join t1 on t1.b= t2.b`

使用内存buffer，减少了t1表的io次数。

**上面sql的大致流程如下：**

1. 把 t2 (小表)的**所有数据**放入到内存 join_buffer 中  //100次
2. 把表 **t1 中每一行取出来**，内存中和 join_buffer 中的数据做对比  //  扫描t1：10000  * 100   
3. 返回满足 join 条件的数据(写回磁盘，内存释放)

总次数100*10000=100万次：

### in和exsits

in：适合 子查询表 < 外面查询表

exits：适合 外查询表 < 子查询表

exits原理：从A表中查询出字段，再到b表中扫描。

```sql
select * from A where exists (select 1 from B where B.id = A.id)
 #等价于:
 for(select * from A){
		select * from B where B.id = A.id
 }
```

#mysql的锁

##锁分类

* 性能上：**乐观锁**( MVCC )和**悲观锁**
* 类型分： **读锁**和**写锁 (**悲观锁)
  *  读锁（**共享**锁）：同一数据，**不会阻塞读锁**
  *  写锁（**排它**锁）：阻断**写锁和读锁**。
*  粒度： **表锁**和**行锁** 

## 表锁和行锁

### 表锁

> 场景： 对全表迁移的时候，锁全表。

ock table 表名称 read(write);

####表锁的优缺点？

* 开销小，加锁快；不会出现死锁

* 锁定粒度大，发生锁冲突的概率最高，并发度最低；

### 行锁如何使用？

innodb：支持事务和行锁。

行锁支持的事务。

### 事务(ACID)

- **原子性**(Atomicity) ：事务是一个原子操作单元,其对数据的修改,**要么全都执行,要么全都不执行。**
- **一致性(**Consistent) ：在**事务开始和完成时,数据都必须保持一致状态。**
- **隔离性**(Isolation) ：数据库系统提供一定的**隔离机制**,保证事务在不受外部并发操作影响的“独立”环境执行。 事务处理的**中间状态对外部是不可见的。**
- **持久性**(Durable) ：事务完成之后, **数据的修改是永久性的**

为什么需要事务？

转账等。

## 并发事务的问题？

* **更新丢失**: 当两个或多个事务选择同一行，**更新时会覆盖值**.
* **脏读**: 事务A读取到了事务B已经**修改但未提交**的数据。如果b回滚就是脏数据。
* **不可重复读**: 事务A读取到了事务B已经提交的**修改**数据，不符合隔离性。
* **幻读**: 事务A读取到了事务B提交的**新增**数据，不符合隔离性。(一个事务按相同的查询条件**重新读取以前检索过的数据**，却发现其他**事务插**
  **入了满足其查询条件的新数据**，这种现象就称为“幻读”。)

##事务隔离级别

- **读未提交(Read uncommitted)**：一个**事务未提交**，它的变更也能被别的**事务读取**。
- **读提交(Read committed)：**一个事务提交之后，它做的变更才会被其他事务看到。解决脏读

* **可重复读(Repeatable read)：**一个事务**执行过程中的数据，启动时看到的数据是一致的**。当然对未提交变更对其他事务也是不可见的。解决不可重复读

- **串行化(Serializable)**： 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当**出现读写锁冲突的时候**，后访问的**事务必须等前一个事务执行完成**，才能继续执行。解决幻读

隔离级别高，并发小。

设置隔离级别：`set session transaction isolation level serializable`



## 死锁

session1，锁住行1，请求行2。

session2，锁住行2，请求行1。

##为什么Mysql默认可重复读？

mysql默认innodb的sql会使用行锁。

https://www.cnblogs.com/shoshana-kong/p/10516404.html

## 间隙锁

#### 间隙是什么？

![image-20210904170841338](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210904170841338.png)

###mysql默认可重复读，如何解决幻读问题？

下面sql会对，间隙的行加写锁。

`update account set name ='zhuge' where id > 10 and id <=20;`

其他Session**不能再间隙里插入或修改数据。** 不能插入，就解决了幻读问题。

##无索引行锁会升级为表锁

InnoDB**行锁加在索引上**，如果对**非索引字段更新**, **行锁可能会变表锁。**

锁定某一行

* lock in share mode(共享锁) 

* for update(排它锁)

## 优化

* **使用索引**，避免无索引字段，**行锁升级为表锁**。
* **减少查询范围，避免间隙锁**
* **尽可能低级别事务隔离**
* 尽量**控制事务大小**，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行



#分库分表













1. 什么是表分区？
2. 表分区与分表的区别
3. 表分区有什么好处？
4. MySQL主从复制原理流程
5. MySQL分库分表了解过吗？
6. MySQL的redo日志和undo日志分别有什么用？
7. MySQL的redo日志的刷盘时机
8. MySQL有哪些日志，分别是什么用处？
9. MySQL的binlog有有几种录入格式?分别有什么区别?





1. 在建立索引的时候,都有哪些需要考虑的因素呢?
2. 说一下什么是事务的ACID属性吧
3. 事务的隔离级别了解过吗？
4. 说说InnoDB的索引原理
5. 说说InnoDB的MVCC机制
6. 有了解过“回表”的概念吗？什么情况下会出现“回表”？
7. MySQL索引的类型
8. 有做过MySQL的索引优化吗？
9. 什么是聚簇索引？
10. InnoDB有聚簇索引吗？MyIsam呢？
11. MyIsam的数据是怎么存储的？
12. InnoDB的数据是怎么存储的？
13. InnoDB主键索引跟非主键索引在数据存储上的差异
14. InnoDB删除某条记录后，内部会怎么处理？
15. InnoDB如果没有设置主键的话，它内部会怎么处理？
16. 为什么InnoDB一定会生成主键？
20. MySQL有哪些锁？以及各种锁的作用？
18. MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义
23. 在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?
24. 为什么要尽量设定一个主键?
25. 主键使用自增ID还是UUID?
26. 字段为什么要求定义为not null?
27. 如果要存储用户的密码散列,应该使用什么字段进行存储?
24. varchar(10)和int(10)代表什么含义?
30. 超大分页怎么处理?
31. 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?
32. 什么是存储过程？有哪些优缺点？
28. 什么情况下应不建或少建索引
37. MVVC了解过吗
38. 在MVCC并发控制中，读操作可以分成哪几类？
39. 行级锁定的优点
40. 行级锁定的缺点
41. key和index的区别
34. delete、truncate、drop区别
44. 自增主键最大ID记录，MyISAM和InnoDB分别是如何存储的
45. Mysql如何优化DISTINCT?
46. 解释MySQL外连接、内连接与自连接的区别