##什么是Redis？ 

redis(Remote Dictionary Server) : C语言编写的高性能**非关系型**（NoSQL）的**键值对数据库**。 

键的类型只能为字符串，值 支持五种数据类型：字符串、列表、集合、散列表、有序集合。 

基于内存，读写速度快，10万QPS

## Redis的优缺点？

**优点 **

- **读写性能**优异，10万QPS。 
- 支持**数据持久化**，支持AOF和RDB两种持久化方式。 
- 支持**事务**，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并 后的原子性执行。 
- **数据结构丰富，**除了支持string类型的value外还支持hash、set、zset、list等 数据结构。 
- 支**持主从复制**，主机会自动将数据同步到从机，可以进行读写分离。 

**缺点 **

- 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写
- Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求 失败，需要等待机器重启或者手动切换前端的IP才能恢复。 
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入**数据不一 致的问题**，降低了系统的可用性。 
- Redis 较难支持在线扩容。 

## Redis有哪些数据类型 

Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分 的使用要求 数据类型 可以存储 的值 操作 应用场景

| 数据类型 | 可以存储 的值            | 操作                                                         | 应用场景                                                     |
| :------: | :----------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
|  STRING  | 字符串、 整数或者 浮点数 | 对整个字 符串或者 字符串的 其中一部 分执行操 作 对整数和 浮点数执 行自增或 者自减操 作 | 做简单的 键值对缓 存                                         |
|   LIST   | 列表                     | 从两端压 入或者弹 出元素 对单个或 者多个元 素进行修 剪， 只保留一 个范围内 的元素 | 存储一些 列表型的 数据结 构，类似 粉丝列 表、文章 的评论列 表之类的 数据 |
|   SET    | 无序集合                 | 添加、获 取、移除 单个元素 检查一个 元素是否 存在于集 合中   | 交集、并 集、差集 的操作， 比如交 集，可以 把两个人 的粉丝列 |
|   HASH   | 包含键值 对的无序 散列表 | 添加、获 取、移除 单个键值 对 获取所有 键值对  检查某个 键是否存 在 | 结构化的 数据，比 如一个对 象                                |
|   ZSET   | 有序集合                 | 添加、获 取、删除 元素 根据分值 范围或者 成员来获 取元素  计算一个 键的排名 | 去重但可 以排序， 如获取排 名前几名 的用户                   |



## 用Redis做延时队列和阻塞队列，具体应该怎么实现？



### 延时队列

Redis的数据结构**Zset，同样可以实现延迟队列的效果**，主要利用它的**score属性**，Redis通过score来为集合中的成员进行从小到大的排序。

![2.png](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/044f49cd13a6958be03611da03f37b15.png)

###阻塞队列

B**LPOP** key [key ...] timeout //从key列表表头弹出一个元素，若列表中没有元素，**阻塞等待 timeout秒**,如果timeout=0,一直阻塞等待

B**RPOP** key [key ...] timeout  //从key列表表尾弹出一个元素，若列表中没有元素，**阻塞等待 timeout秒**,如果timeout=0,一直阻塞等待



## Redis为什么这么快 

1. 完全基**于内存操作**，非常快速。数据存在内存 中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)； 
2. 采用**单线程**，避免了不必要的上下文切换 ，也不存在多进程或者 多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁 操作，没有因为可能出现死锁而导致的性能消耗； 
3. 使用**多路 I/O 复用模型，非阻塞 IO**； 

因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。

###Redis 单线程如何处理那么多的并发客户端连接？

Redis的IO多路复用：redis利用**epoll来实现IO多路复用**

# 持久化

持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 

## 1.RDB

默认Redis将数据库的快照**保存在 dump.rdb的二进制文件中。**

自动保存数据集： save 秒  修改次数  （N 秒内数据集至少有 M 个改动）

ex: save 60 1000:表示 60秒内至少有1000个键改动

手动指令生成RDB快照

* 进入redis客户端执行**命令save**或**bgsave**可以生成**dump.rdb文件，**执行命令，将所有**redis内存快照到一个新的rdb文件里，覆盖原有rdb快照文件**。
* save是同步命令，**bgsave是异步**命令，bgsave会从redis**主进程fork（fork()是linux函数**）出一个子进程专门用来生rdb快照文件

###1.1save与bgsave对比

| 命令                  | save             | bgsave                                         |
| --------------------- | ---------------- | ---------------------------------------------- |
| IO类型                | 同步             | **异步**                                       |
| 是否阻塞redis其他命令 | 是               | **否(在生成子进程调用fork函数时会有短暂阻塞)** |
| 复杂度                | O(n)             | O(n)                                           |
| 优点                  | 不会消耗额外内存 | 不阻塞客户端命令                               |
| 缺点                  | 阻塞客户端命令   | 需要fork子进程，消耗内存                       |

###1.2RDB的缺点：

快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成**故障停机**， 那么**服务器将丢失最近写入、且仍未保存的那些数据**。

从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： **AOF 持久化，将修改的每一条指令记录进文件appendonly.aof中**

## 2.AOF

AOF 持久化： 将修改的每一条**将指令记录进文件appendonly.aof中**

 配置文件中开启：`appendonly yes`

###2.1恢复策略

AOF方式数据恢复： 程序就可以**通过重新执行 AOF 文件中**的**命令**来达到重建数据集的目的。

* appendfsync **always**：每**次有新命令追加到 AOF** 文件时就执行**一次 fsync** ，非常慢，也非常安全。

* appendfsync **everysec**：**每秒 fsync 一次**，足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。

* appendfsync **no**：从不 fsync ，将数据**交给操作系统来处理**。更快，也更不安全的选择

###2.2AOF重写

 AOF会定期根据**内存的最新数据**生成aof文件

####2.2.1AOF重写频率？

* 根据AOF文件达到**指定大小**，触发重写
* 根据AOF中重写后文件，**增加100分之多少**，再次触发重写
* 手动AOF重写:  redis客户端执行**命令bgrewriteaof**重写AOF
  * AOF重写redis**会fork一个子进程**去做，不会对redis有太多

> auto-aof-rewrite-min-size 64mb        //aof文件至少要**达到64M**才会自动重写，文件太小恢复速度本来就很快，重写的意义不大
>
> auto-aof-rewrite-percentage 100        //aof文件自上一次重写后文件大小**增长了100%**则再次触发重写

##RDB和AOF的区别？

如果既有aof文件又有rdb文件，会**优先选择aof文件**，数据更安全

| 命令       | RDB        | AOF          |
| ---------- | ---------- | ------------ |
| 启动优先级 | 低         | 高           |
| 体积       | 小         | 大           |
| 恢复速度   | 快         | 慢           |
| 数据安全性 | 容易丢数据 | 根据策略决定 |

缺点：**AOF宕机后，恢复速度慢。**

##Redis 4.0 混合持久化

**AOF在重写时,之前的内存做RDB快照处理**，并且将**RDB快照内容**和**增量的AOF**修改内存数据的**命令**存在一起，都写入新的AOF文件。

混合持久化文件结构：RDB+AOF

![image-20210906105138793](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210906105138793.png)



## Redis主从工作原理

###1.全量复制

1.从节点(slave)发送**psync命令，建立socket长连接**

2.master收到命令，bgsave生成最新rdb快照数据

3.send rdb数据

4.在bgsave过程中的数据放入buffer中，master--rdb->slave，合并rdb

![image-20210906105302146](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210906105302146.png)



###2.部分复制---增量复制

1.从节点(slave)重新连接从节点(master)，发送**psync()命令+offset偏移量**

2.master**判断offest在buffer中，发送**offset之后的数据；否则**全量同步**

3.master通过socket长连接持续发送写命令给从节点。保证主从数据一致性

如果slave的offset(偏移量) 与 Master中的**buffer中的偏移量相差特别大，会触发一次全量同步**.ex

> buffer固定的大小，一般不会大。ex:1M



![image-20210906105414848](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210906105414848.png)

#哨兵与集群

## sentinel哨兵

sentinel哨兵是**特殊的redis服务**，不提供读写服务，主要用来**监控redis实例节点。**

**集群监控**：负责监控 redis master 和 slave 进程是否正常工作。

**消息通知**：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。

**故障转移**：Redis的主master挂机了，哨兵会选择一个新的选举一个master。

**配置中心**：如果故障转移发生了，通知 client 客户端新的 master 地址。(哨兵架构下client端**第一次从哨兵找出redis的主节点**)

哨兵至少需要 3 个实例，来保证自己的健壮性。

哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。

##什么是集群？为什么选择集群？

定义：是由多个**主从节点群组成的分布式服务群**，它具有**复制，高可用，分片**特性。

<img src="https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210906111637627.png" alt="image-20210906111637627" style="zoom:50%;" />

因为主从模式有如下缺点：

1. 并发受限制：**一个master 写操作**。最多10万QPS,高并发下，必须扩容。

2. **master节点异常**：会**主从切换瞬间存在访问瞬断**情况。

3. master的**内存不宜设置太大**。否则**持久化文件过大**，影响**重启和主从复制的效率**。

key的数据分片的。可以水平扩容，

##数据分片的原理

Redis 集群将所有数据划分为：**16384个(slots)槽位**，**每一个节点负责其中一部分槽位**。槽位的信息分配到每个节点中。

### 槽位定位算法

Cluster 默认会对 key 值使用 **crc16 算法**进行 **hash 得到一个整数值**，然后用这个整数值对 **16384 进行取模**来得到具体槽位。

* HASH_SLOT = **CRC16(key) mod 16384**

####跳转重定位

当客户端向一个错误的节点发出了指令，该**节点会发现指令的 key 所在的槽位**并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了**跳转到正确的节点上去操作**，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。



##Redis集群节点间的通信机制

维护集群的元数据有两种方式：

* 集中式
* **gossip**

### 网络抖动引发主从切换

clusternodetimeout：某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换

* 不能设置太短。

###Redis集群选举原理分析

当slave发现自己的**master变为FAIL状态时**，便尝试进行Failover，以期成为新的master。选举slave --> master 其过程如下：
1.slave发现自己的master变为FAIL
2.将自己记录的集群**currentEpoch**加1，并广播**FAILOVER_AUTH_REQUEST** 信息
3.其他主节点收到该信息，只有**主节点master响应**，并且未发送过ack，因为一个主节点只能发送一次ack，所以发送FAILOVER_AUTH_ACK。
4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK

5.slave收到超过**半数master的ack 大于等于(N/2+1)张支持票**后变成新Master(这里解释了集群为什么**至少需要三个主节点**，如果只有两个，当其
中一个挂了，只剩一个主节点是不能选举成功的)
6.广播**Pong消息**通知其他集群节点

###哨兵leader选举流程-

> 与集群中master选集相似

如果leader下线后，哨兵从节点进行选举。

 如果所有**超过一半的sentinel选举某sentinel作为leader**。 选举成功。
哨兵集群只有一个哨兵节点，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。
不过为了高可用一般都推荐**至少部署三个哨兵节点**。 

###Redis集群哨兵为什么至少需要三个master节点，并且推荐节点数为奇数？

* 选举成功的条件 >= N/2+1
* 奇数的master节点更多的是从节省机器资源角度出发说的
  *  ex:  3**个节点  4个节点  同时挂两个**   **3节点，4节点都不能用**。还不如5个。



##分布式锁

setnx演变：

1. 使用redis的**setnx操作**。
   1. 如果宕机之后，锁不能释放
2. 设置超时时间
   1. 锁失效：如果超时过后，线程2进入，线程1会释放线程2的锁
3. 加入判断,只有自己的锁才能释放
   1. 判断后，宕机，锁不能释放

jedis.setnx(key,value)



![image-20210906141548875](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210906141548875.png)

## redisson---锁续命

redisson：java客户端，针对分布式场景下的解决方案。

redission:底层使用lua脚本语言。

* redissonLock.lock();  --- 不会疯狂自旋，会判断超时时间。
* redissonLock.unlock();

底层操作：如果线程还持有锁，进行延长锁的时间。

![image-20210906142022357](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210906142022357.png)

##LUA脚本

使用Lua语言编写脚本传到Redis中执行。

* 1、**减少网络开销**：本来几次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器上完成。使用脚本，减少了网络往返时延。 
* 2、**原子操作**：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过redis的批量操作命令(类似mset)是原子的。
* 3、**替代redis的事务功能**：redis自带的事务功能很鸡肋，报错不支持回滚，**而redis的lua脚本几乎实现了常规的事务功能**，支持报错回滚操作。

## redis如何解决幂等？

在分布式系统中，我们无法保证消息能正常传递给服务提供者，如果可以**尝试数次**，那么消息不能传达的概率就会大大降低，从而降低数据的不一致性。

但是使用多次尝试也会带来一个问题——需要防止多次尝试调用造成的数据不一致，这便是我们需要谈的幂等性。

幂等性，是指在HTTP协议中，**一次和多次请求某一个资源，对于资源本身应该具有同样的结果，也就是其执行任意多次时，对资源本身所产生的影响，与执行一次时的相同**。

为需要保证幂等性的**每一次请求创建一个唯一标识**`token`, 先获取`token`, 并将此`token`存入redis, 请求接口时, 将此**`token`放到header**或者作为**请求参数**请求接口, 后端接口**判断redis中是否存**在此`token`:

- 如果**存在**, 正常处理业务逻辑, 并从**redis中删除**此`token`, 那么, 如果是重复请求, 由于`token`已被删除, 则**不能通过校验,** 返回`请勿重复操作`提示
- 如果**不存在**, 说明**参数不合法或者是重复请求,** 返回提示即可

 

#缓存穿透？缓存失效？缓存雪崩？缓存并发？

## 缓存穿透

####1.解释：

是指**查询一个根本不存在的数据**， 缓存层和存储层都不会命中。

####2.问题：

缓存穿透将**导致不存在的数据每次请求都要到存储层去查询**， 失去了**缓存保护后端存储**的意义。到时数据库压力过大。

####3.场景：

造成缓存穿透的基本原因有两个：

* 第一， 自身业务代码或者数据出现问题。
* 第二， 一些恶意攻击、 爬虫等造成大量空命中

####4.解决

##### 4.1缓存空对象

##### 4.2布隆过滤器

当布隆过滤器说某个值**存在时**，这个值**可能不存在**；当它说**不存在，就一定不存在。**

* 添加**key时**，适用多个**hash函数对key进行hash运算 % length。**
* 将多个hash函数，的位置值为1
* 查询是，进行hash算法。只要有一个为0，不存在。全为1，可能存在

![image-20210906142938254](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210906142938254.png)

##缓存失效

解释：在**秒杀前，将热点数据放入缓存中**，设置了失效时间。如果所有的都**设置相同的过期时间，超时时间过，缓存数据全部失效**。

解决：热点商品，设置**随机过期时间**



##缓存雪崩

解释：由于**redis缓存崩溃**，导致所有请求直接发放到存储层，直接干崩。

解决：

* 1） **保证缓存层高可用性**，哨兵+集群
* 2） 依赖隔离组件为**后端限流并降级**。比如使用sentinel限流降级组件。

##缓存并发

解释：重建缓存：从数据库获取新值

###问题

“缓存+过期时间”的问题：

* **当前key是一个热点key**（例如一个热门的娱乐新闻），并发量非常大。
* **重建缓存非常耗时**， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。非常

* 在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大

###解决：加互斥锁

**利用互斥锁**来解决，此方法**只允许一个线程重建缓存**，其他线程等待重建缓存的线程执行完， **重新从缓存获取数据**即可。

多大

的并发，只用一个线程重建缓存。

![img](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/163758-20180918110005948-2118630098.png)



## 缓存一致性

1. **延迟双删**。但不好估计时间

2. **队列**，这就**串行化了**。性能会受到影响。
3. **普通分布式锁**。对key加锁。串行化，性能差。
4. **加分布式读写锁（适合读多写少的场景）**

分布式锁的优化：

###1.双写不一致情况

指的是，**写数据库**和**更新缓存**两个之间有延迟。



<img src="https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210911112726650.png" alt="image-20210911112726650" style="zoom:80%;" />

###2.读写并发不一致

**写数据库**后，**直接删除缓存**，等到另一个线程读**取数据库后，读的数据放入缓存。**

当**查数据库和更新缓存有延迟**，导致读写并发不一致。

<img src="https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210911112817392.png" style="zoom:67%;" />

### 3.延迟双删

在每次写数据库删除缓存之后，隔一段时间再进行一次删除操作。

缺点：不好掌握延迟的时间。

<img src="https://ljjblog.oss-cn-beijing.aliyuncs.com/img/20210529000850310.png" alt="img" style="zoom:33%;" />

### 4.内存队列和普通分布式锁

内存队列是串行化的。

### 5.加分布式读写锁（适合读多写少场景）

读操作之间不会互斥。

读锁和写锁用的是同一个key，这样也就能控制同一个资源。看源码可以看到**Redisson的读写锁底层也是用Lua脚本操作**Redis来实现的，只是**在设置key的时候还额外指定了mode，来标识加的是读锁（read模式）还是写锁（write模式）**。

Redisson的读写锁底层在加锁时，如果发现之前加的是**read模式读锁或者没加锁**，那么就可以直接操作；如果发现之前加的是w**rite模式的锁，那么就要等这把锁释放掉再继续操作。**

读锁：

![在这里插入图片描述](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/20210529004151225.png)

写锁：

![img](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/20210529004350911.png)

##Redis中的大key？

#### 什么是big key

1. 字符串类型：它的big体现在**单个value值很大**，一般认为超过**10KB就是bigkey。**
2. 非字符串类型：哈希、列表、集合、有序集合，它们的big体现在**元素个数太多**

####bigkey有什么危害？

1.**导致redis阻塞**
2.**网络拥塞**

* 获取时产生的网络流量较大，影响吞吐量。并发就小。

3.过期删除

* 当它过期后，会被删除，如果没有使用Redis 4.0的过期**异步删除**(lazyfree-lazyexpire yes)，就会存在阻塞Redis的可能性。

 ###如何优化bigkey

* 拆分
  * big list：list1 list2 list3 ....每个key存储一部分值。`(list存储100万，分成100个key，一个key存储1万)`
* 尽量不要取出全部值， 少适用hgetall ， 适用hmget。





##过期策略

https://www.cnblogs.com/xuliangxing/p/7151812.html

#五种数据结构的实现

##1.SDS对象

SDS对象，此对象中包含三个属性：

- len    : buf中**已经占有的长度(**表示此字符串的实际长度),不包括\0
- free  : buf中**未使用**的缓冲区长度
- buf[] :  **实际保存字符串数据**的地方

![img](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/1120165-20180528075607627-218845583.png)

###好处：

###1.常数复杂度获取字符串长度

　　由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C  语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。

###2.杜绝缓冲区溢出

　　我们知道在 C 语言中使用 strcat  函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出

###3减少修改字符串的内存重新分配次数

C语言由于**不记录字符串的长度**，所以如果要修改字符串，必须要重新分配内存（先释放再申请）

因为如果没有重新分配，**字符串长度增大**时会造成**内存缓冲区溢出**，**字符串长度减小**时会造成**内存泄露**(没有立即回收多出来的字节)。

而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：

* **空间预分配**：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。
  * len < 1MB 	buf实际长度：len + len +1byte;
  * len > 1MB    buf实际长度：len + 1MB +1byte;
* **惰性空间释放**：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）

###4.二进制安全

　　因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；

而所有  SDS 的API 都是以**处理二进制的方式**来处理 buf 里面的元素，**SDS** 不是**以空字符串**来判断是否**结束**，而是**以 len  属性表示的长度来判断字符串是否结束。**

###5.兼容部分 C 字符串函数

　　虽然 SDS 是二进制安全的，但是一样**遵从每个字符串都是以空字符串结尾的惯例**，这样可以重用 C 语言库<string.h> 中的一部分函数。

## 2.链表

List的6个属性：

* 1.头指针 head
* 2.尾指针 tail
* 3.节点长度 len
* 4.复制函数 dup()
* 5.释放函数 free()
* 6.比对函数 match()

ListNode底层是一个**双向无环链表**。

## 3.字典

字典又称为映射（map），是一种用于**保存键值对的抽象数据结构**。字典中的**每一个键 key 都是唯一的**，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。

### 属性

dictht

* 哈希数组
* 哈希表大小 size
* 哈希表大小掩码，用于计算索引值：sizemask = size - 1
* 已有节点数量  used

dictEntry

* key
* 值{val ,}
* 下一个哈希表节点: next 

### 哈希算法

计算hash后 & 上数组长度- 1

index = hash & dict -> ht[X].sizemask 

解决冲突链地址法

###rehash扩容和收缩：

　　　　　　1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。

　　　　　　2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。

　　　　　　3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。

#####触发扩容的条件：

　　　　　　1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。

　　　　　　2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。

　　　　ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。

###渐近式 rehash

渐进式  rehash：扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。

如果键值对有几百万，几千万甚至几亿，那么要一次性的进行  rehash，势必会造成Redis一段时间内不能进行别的操作。

所以Redis采用渐进式  rehash,这样在进行渐进式rehash期间，

字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。

但是进行 增加操作，一定是在新的哈希表上进行的。

## 4.跳跃表

　跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。

将有序链表改造为**支持“折半查找”算法**，可以**快速的插入，删除，查找操作。**





具有如下性质：



## 5.整数集合

　　整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。

　　length 属性记录了 contents 数组的大小。

　　需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。

###5.1升级

当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：

　　1、根据新**元素类型，扩展整数集合底层数组的大小，并为新元素分配空间**。

　　2、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。

　　3、将**新元素添加到整数集合中（保证有序）。**

　**升级能极大地节省内存。**

###5.2降级

　　整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

## 6.压缩列表

　压缩列表（ziplist）是Redis为了节省内存而开发的，是由**一系列特殊编码**的**连续内存块组成的顺序型数据结构**。

压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是**将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。**

# 淘汰策略

1. 被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key
2. 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key
3. 当前已用内存超过maxmemory限定时，触发主动清理策略

LRU 算法（Least Recently Used，最近最少使用）
淘汰很久没被访问过的数据，以最近一次访问时间作为参考。



1. Redis key的淘汰策略有哪些？
2. Redis在什么情况下会触发key的回收？







1. Redis主要消耗什么物理资源？
2. 一个字符串类型的值能存储最大容量是多少？
3. Redis为什么那么快？
4. Redis是单线程还是多线程？
5. Redis 官方为什么不提供 Windows 版本？
6. 为什么 Redis 需要把所有数据放到内存中？
7. Redis如何设置密码及验证密码？
8. Redis集群如何选择数据库？
9. 缓存失效？缓存穿透？缓存雪崩？缓存并发？
10. Redis中的热key怎么处理？
11. Redis中的大key怎么处理？
12. 使用Redis统计网站的UV，应该怎么做？
13. Redis事务机制了解过吗？
14. Redis key的淘汰策略有哪些？
15. Redis在什么情况下会触发key的回收？
17. Redis的持久化了解过吗？
18. Redis在集群种查找key的时候，是怎么定位到具体节点的？
19. Redis集群各个节点之间是怎么保持数据一致性的？
20. 用Redis做延时队列，具体应该怎么实现？
21. Redis String的内部编码有哪些？
22. Redis 集群方案应该怎么做？都有哪些方案？
23. Redis 集群方案什么情况下会导致整个集群不可用？
24. MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？
25. Redis有哪些适合的场景？
26. Redis和Redisson有什么关系？
27. Redis中的管道有什么用？
28. Redis如何做内存优化？

