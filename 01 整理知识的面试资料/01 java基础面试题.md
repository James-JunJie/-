##形参与实参

基本类型传递值，引用类型传递地址。

形参：全称**形式参数**，方法**定义中**的参数    void swap(int a,int b)//形参

实参：全称**实际参数**，方法**调用中**的参数   swap(a,b)//a,b实参

基本类型包括： `byte`, `short`, `int`, `long`, `char`, `float`, `double`, `boolean` 这八大基本数据类型

值传递与引用传递：

* 值传递：传递基本数据类型,   a = 10 , change(a);//a的值不会改变
  * ​	因为：a在栈中局部变量表空间
* 引用传递：传递引用类型，int[] arr ={10,20};change(arr);//会改变
  *    arr[]是引用，堆内存的值

## 值传递和引用传递有什么区别

**java都是值传递。也就是说，方法得到的是所有参数值的 一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。** 

值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷 贝，也就是说传递后就互不相关了。 

引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引 用的地址，也就是**变量所对应的内存空间的地址**。传递的是值的引用，也就是说 传递前和传递后都指向同一个引用（也就是同一个内存空间）。

## 进制的表示

* 二进制：开头 0b
* 八进制：开头 0
* 十六进制：开头  0X



## 构造器是否可以被重写

**构造器不能被继承，因此不能被重写**，但可以被重载。 

##  Java重写与重载的区别

方法的**重载和重写都是实现多态的方式**，区别在于前者实现的是**编译时的多态性（重载）**，而后者实现的是**运行时的多态性**。 

重写：**在子类中把父类本身有的方法**重新写一遍，**在方法名，参数列表，返回类型都相同的情况下，对方法体进行修改或重写，**注意**子类函数的访问修饰权限不能少于父类的。**

重载：在**同一个类中**，定义了多个**同名的方法**，但每个方法具有**不同的参数类型**或**参数个数**，这些同名方法，就构成了重载关系。对返回值没有要求。

两同三不同:

——同一个类，同一个方法名。

——不同：参数列表不同。（**类型，个数**）

## HashCode 与 equals 之间的区别

* 两个对象的hashCode()相等，equals()不一定相等。(对象值不一定相等)
* 两个对象的equals()相等，hashCode()必相等。

Object默认equals:

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

## 我们重写了equals方法之后，一定要重写HashCode为什么？

我们要遵循上述规则：

所以重写equals方法的时候，需要重写hashcode。保证equals相等，hashcode（）相等。

不重写的话会怎么样？hashcode不相同。

为什么重写，保证在hashmap等集合中使用。

Objects.hash()

```java
public static int hashCode(Object a[]) {
    if (a == null)
        return 0;

    int result = 1;

    for (Object element : a)
        result = 31 * result + (element == null ? 0 : element.hashCode());

    return result;
}
```

31 * i == (i << 5）- i   性能提高，乘法能够使用移位和减法操作。

## HashMap 与 HashTable有哪些区别

HashMap 线程不安全，效率比较高，可以key为空值,并且存储数组第0个位置， 初始值是16。

HashTable 线程安全，效率比较低，key不可以空值，初始值：11.





## JVM、JRE和JDK的关系 

![image-20210827152543796](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210827152543796.png)

##1.面向对象和面向过程的区别

#### 面向过程：

> 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次[调用](https://baike.baidu.com/item/调用/3351318)就可以了。

优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，能是最重要的因素。
缺点：没有面向对象易维护、易复用、易扩展

#### 面向对象：

优点：**易维护、易复用、易扩展**，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

缺点：性能比面向过程低
面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。

面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。

##2.说下面向对象的四大特性

* **抽象**： 将一类对象的**共同特征总结出来构造类**的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是 什么。 

- **封装** : 封装把一个**对象的属性私有化**，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没 有提供给外界访问的方法，那么这个类也没有什么意义了。 

- **继承** : 继承是使用**已存在的类的定义作为基础建立新类的技术**，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用 继承我们能够非常方便地复用以前的代码。

  ​	关于继承如下 3 点请记住：

  ​		1.子类拥有父类**非 private 的属性和方法**。

  ​		2.子类可以**拥有自己属性和方法**，即子类可以对父类进行扩展。 

  ​		3.子类可以用**自己的方式实现父类的方法**。 

- **多态** : 所谓多态就是指程序中**定义的引用变量所指向的具体类型**和**通过该引用变量发出 的方法调用在编程时并不确定**，而是在程序运行期间才确定，

  即一个引用变量到 底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的 方法，必须在由程序运行期间才能决定。

  在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。 



###2.1Java 面向对象编程三大特性：封装 继承 多态

**java只能支持单继承**

**多态性**：**多态是指通过指向父类的指针，来调用在不同子类中实现的方法**。父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。

方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。 

一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是 哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对 象精髓的东西，要实现多态需要做两件事： 

**多态的实现方式**

* **方式一：重写**

* **方式二：接口** 

* **方式三：抽象类和抽象方法**



**多态存在的三个必要条件**

- 继承

- 重写

- 父类引用指向子类对象

  

##3.Java语言有些特点

* 简单易学（Java语言的语法与C语言和C++语言很接近） 

* 面向对象（封装，继承，多态） 

* 平台无关性（Java虚拟机实现平台无关性） 一次编译，到处运行

* 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的） 

* 支持多线程（多线程机制使应用程序在同一时间并行执行多项任） 

* 健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等） 

* 安全性

##4.什么是Java程序的主类？应用程序和小程序的主类有何不同？

简单说应用程序是从**主线程启动(也就是main()方法)**。

applet小程序没有main 方法，主要是**嵌在浏览器页面上运行(调用init()线程或者run()来启动)**，嵌入浏 览器这点跟flash的小游戏类似。

##5.访问修饰符public,private,protected,以及不写（默认）时的区别？

**定义**：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访 问。Java 支持 4 种不同的访问权限。 

**分类**：

- private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部 类） 
- default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用 任何修饰符。使用对象：类、接口、变量、方法。 
- protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意： 不能修饰类（外部类）。 
- public : 对所有类可见。使用对象：类、接口、变量、方法

![image-20210827153119047](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210827153119047.png)

##6.float f=3.4;是否正确？

不正确。3.4 是**双精度数**，将双精度型（double）赋值给浮点型（float）属于 下转型（down-casting，也称为窄化）会造成**精度损失**，

因此需要强制类型转 换**float f =(float)3.4; 或者写成 float f =3.4F;。**

##7.Java有没有goto？

goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。

##8.&和&&的区别？

&运算符有两种用法：(1)**按位与**；(2)**逻辑与**。(要求两端都为true) 

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要 求运算符左右两端的布尔值都是true 整个表达式的值才是 true。

&&之所以称为短路运算，是因为如果&&左边的表达式的值是 false，右边的表达式会被直 接短路掉，不会进行运算。 

注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

##9.Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？

返回与参数最接近的long ，关系四舍五入到正无穷大

Math.round(11.5) ： 11

Math.round(1-11.5):  -12

## 10.什么是Java注释

用于解释说明程序的文字

## 11.Java有哪些数据类型

基本数据类型 

- ​	数值型 
  ​		整数类型(byte,short,int,long) 
  ​		浮点类型(float,double)   
- ​	字符型(char) 
- ​	布尔型(boolean) 

引用数据类型

- ​	类(class) 
- ​	接口(interface) 
- ​	数组([]) 

![image-20210827154855186](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210827154855186.png)

## 12.final 有什么用？

https://blog.csdn.net/weixin_39682673/article/details/111129972

用于修饰**类**、**变量**和**方法，参数**；

- 被final修饰的类**不可以被继承**
- 被final修饰的方法**不可以被重写**，但**可以被重载**
- 被final修饰的变量**不可以被改变**，被final修饰变成**编译期常量**。常量存储在常量池中。
- 被final修饰的参数：方法内无法更改参数引用指向的对象



##13.final finally finalize的区别

- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类 。对象的自救。

Finalize()方法，对象的自救条件:

- Finalize()只**能执行一次** 
- 必须**覆盖Object中的finalize()方法。**

终结器引用（FinalReference）

无需手动编码，但其内部配合**引用队列F-Queue**使用，在垃圾回收时，**终结器引用入队**（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象.

##13.String str = "i" 和String str = new String("1")一样吗？

不一样

##14.字符型常量和字符串常量的区别

1. 形式上: 字符常量是**单引号**引起的一个字符 字符串常量是双引号引起的若干个字符
2. 含义上: 字符常量相当于**一个整形值(ASCII值)**,可以**参加表达式运算** **字符串常量代表一个地址值**(该字符串在内存中存放位置)
3. 占内存大小 **字符常量只占一个字节** 字符串常量占若干个字节(至少一个字符结束标志)

##16什么是字符串常量池？

字符串常量池位1.8 之后放入的是堆中，在1.6放入方法区，并且方法区由老年代实现。字符串池由**String类私有的维护**。jvm里面只有一个。一个hashTable结构

* 常量池中的字符串仅是符号，第一次用到时才变为对象
* 利用串池的机制，来避免重复创建字符串对象

* 在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。

 延迟加载（遇到新串时加载）(数据结构：hash表） **Jdk1.8后字符串常量池放入堆中**，而**常量池放在了元空间中**

```java
 String s1 = "a 
 String s2 = "b"; 
 String s3 = "ab"; 
 String s4 = s1 + s2; //new StringBuilder().append("a).append("b).toString() 等于 new String("ab") //放入堆中
 String s5 = "a"+"b"; //javac 在编译期间的优化，结果已经在编译期确定为 ab   而s4中s1是变量
```

##17.StringTable特性(数据结构 hashTable)

- 常量池中的字符串仅是符号，第一次用到时才变为对象

- 利用串池的机制，来避免重复创建字符串对象

- 字符串变量拼接的原理是 StringBuilder （1.8）

- 字符串常量拼接的原理是编译期优化

- 可以使用 intern()方法，主动将串池中还没有的字符串对象放入串池 

- - 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则**放入串池**，放入字符串，同时会把串池中的对象返回
  - 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此**对象复制一份**，放入串池，会把串池中的对象返回

调优：

* 调整-XX: StringTableSize=桶个数 （*如果串多，桶个数设置大* *(**桶小，插入链表速度慢**)*）
* address.add(s.intern()); //读入进集合前，放入串池中。减少内存消耗.

![string](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/string.png)

##18.String 是最基本的数据类型吗

不是，引用类型。char是基本类型。String 底层就是一个 char 类型的数组

##19.String有哪些特性

- 不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。
- 常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。
- final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。

##20.String为什么是不可变的？

简单来说就是String类利用了**final修饰的char类型数组存储字符**，源码如下图所以：

```java
1  /** The value is used for character storage. */

2  private final char value[];
```

String引用改变："Hello"的内存地址转为指向"Hello World"的内存地址

```java
1  String str = "Hello";

2  str = str + " World";

3  System.out.println("str=" + str);
```

##21.是否可以继承 String 类

String 类是 final 类，不可以被继承。

##22.数组有没有 length()方法？String 有没有 length()方法

数组**没有 length()方法** ，**有 length 的属性**。String 有 length()方法。 

##23.在使用 HashMap 的时候，用 String 做 key 有什么好处？

HashMap 内部实现是**通过 key 的 hashcode 来确定 value 的存储位置**，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。

##24.String 类的常用方法都有那些？

- indexOf()：返回指定字符的索引。 
- charAt()：返回指定索引处的字符。
- replace()：字符串替换。 
- trim()：**去除字符串两端空白**。
- split()：分割字符串，返回一个分割后的字符串数组。
- getBytes()：返回字符串的 byte 类型数组。
- length()：返回字符串长度。 
- toLowerCase()：将字符串转成小写字母。 
- toUpperCase()：将字符串转成大写字符。 
- substring()：截取字符串。 
- equals()：字符串比较。

## 25.String和StringBuffer、StringBuilder的区别是什么？

String : **final修饰，不可变。每次创建新对象，理解为常量，线程安全**。

###25.1StringBuilder 和StringBuffer

StringBuilder : 线程不安全。

StringBuffer:  线程安全，方法上加锁

1.知道StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder，它使用字符数组保存字符串，**char[] value，没有加final，所以可变**。对象本身进行操作，而不是生成新的对象并改变对象引用。

##26.Java中为什么要用 clone？

需求：需要一个新对象B，它要A对象完全相同。并且B的初始值是由A对象确定的。修改B不会影响A对象。

Person p1 = p; 引用同一对象。

## 27.Java创建对象的方式和过程？

#### 五种方式

* new 
* Class类的newInstance()方法，调用无参构造器
*  使用Constructor类的newInstance方法
* Clone
* 序列化机制

####创建对象的过程

* 检查是否类加载
* **对象分配空间**
  * 指针碰撞：适用堆中内存绝对规整，中间放一个指针作为分界点(左边使用，右边未使用)。分配内存就是移动指针
  * 空闲列表：记录那些内存块可用。
* **并发安全问题控制**：修改指针会引发并发安全问题
  * CAS：保证更新的原子性。
  * TLAB(本地线程分配缓冲):为每一个线程，预先分配一块内存。
* **对象必要的设置**：那个类实例，hash码，gc分代年龄，偏向锁等等。
* **执行<init()>方法**，即调用构造器。

## 28.new和clone的区别

* new: 对象的初始化，先查看对象所属的**类有没有被加载到内存**
  * 执行类加载过程（加载载并初始化类）加载--验证--准备---解析--初始化----使用---卸载
  * 创建对象。

* clone:  不需要类加载过程。

##29.深克隆和浅克隆？

克隆的步骤：

* 实现Cloneable接口(标识)，
* 重写clone()方法

![image-20210827170615789](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210827170615789.png)

###29.1浅克隆

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    return (Person) super.clone();
}
```

###29.2深克隆

需要将Address实现Cloneable接口

Person类的 clone()方法

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    Person person = (Person)super.clone();
    person.address = (Address) address.clone();
    return person;
}
```

## 30.java为什么需要空参构造方法？

* 子类的实例化 在 父类实例化后。子类如果没有通过 super 来显式调用父类的构造器，默认调用**父类的无参构造器来进行父类的初始化**。如果此时父类没有无参构造器，则会出**现编译错误**。

* 反射的实例化：很多框架都使用了反射 **Class.newInstance() 来进行实例化，使用的也是无参的构造器**，然后通过setter设置内部属性，如果通过**构造器，只能通过类型匹配来调用。**

## 31.Java中实现多态的机制是什么？

**将子类的引用赋给父类对象**。

**多态的实现** 

* 继承

* 重写：重写后，调用子类的 方法。 

* 向上转型：**将子类的引用赋给父类对象**，父类的方法和子类的方法。 

多态分为编译时多态和运行时多态。

* 重载：编译时多态，更加参数列表区分

* 重写：运行时多态。

```java
public class Person {
    public void  run(){
        System.out.println("人跑步...");
    }
}

```

```java
public class Teacher extends Person {

    @Override
     public void  run(){
        System.out.println("人跑步...");
    }

    public void teach(){
        System.out.println("teach");
    }

}
```

 父类只能调用父类成员，如果被子类覆写，调用子类方法。

```java
Person p = new Teacher();
p.run();
```

####向下转型：调用子类未覆写的方法

```java
Teacher p1 = (Teacher) p;
p1.teach();
```

## 32.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？

 错。

* 两个对象的hashCode()相等，equals()不一定相等。(对象值不一定相等)
* 两个对象的equals()相等，hashCode()必相等。

##33.char型变量中能否能不能存储一个中文汉字，为什么？

可以。

在Java中，char类型**占2个字节**

* Java默认采用Unicode编码，一个Unicode码是16位，所以一个**Unicode码占两个字节**，

* Java中无论汉子还是英文字母都是用Unicode编码来表示的。所以，在Java中，char类型变量可以存储一个中文汉字。

## 34.this关键字的用法

this是自身的一个对象，代表对象本身，可以理解为：**指向对象本身的一个指针**。

1. **普通的直接引用**，this相当于是指向当前对象本身。

2. **形参与成员名字重名**，用this来区分：` this.name = name;`

3. 引用**本类的构造函数** :  this(name);

```java
1 class Person{
2 private String name;
3 private int age;
4
5 public Person() {
6 }
7
8 public Person(String name) {
9 this.name = name;
10 }
11 public Person(String name, int age) {
12 this(name);
13 this.age = age;
14 }
15 }
```

##35.super关键字的用法

super可以理解为是指向自己超（父）类对象的一个指针，而这个**超类指的是离自己最近的一个父类。**

super也有三种用法：

1. 普通的直接引用与this类似，super相当于是指向**当前对象的父类的引用**，这样就可以用super.xxx来引用父类的成员。
2. **子类中的成员变量或方法与父类中的成员变量或方法同名**时，用super进行区分
3. 引用父类构造函数

super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。

this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。

##36.this与super的区别

- super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）
- this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
- super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。
- **super()和this()均需放在构造方法内第一行。**
- 尽管可以用this调用一个构造器，但却不能调用两个。
- **this和super不能同时出现在一个构造函数里面**，因为this必然会调用其它的构造函数，其它的**构造函数必然也会有super语句的存在**，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
- this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
- 从本质上讲，**this是一个指向本对象的指针**, 然而**super是一个Java关键字**。

## 37.static存在的主要意义

static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！

static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。

##38.static的独特之处

1. 被static修饰的**变量或者方法**是被所有**对象所共享的**，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。

> 怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？

2.  类加载过程中，初始化阶段<Clinit>()：编译器自动 收集类中所有**类变量的赋值动作**和**静态语句块**(static{}块)中合并产生的。

3. static变量值在类加载的准备阶段，分配空间到**方法区中**。
4. 被static修饰的变量或者方法是优先于对象存在的。所以不能调用非static方法

##39.static应用场景

因为static是被**类的实例对象所共享**，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。

因此比较常见的static应用场景有：

* 1、修饰成员变量 
* 2、修饰成员方法 
* 3、静态代码块 
* 4、修饰类【只能修饰内部类也就是静态内部类】 
* 5、静态导包

##40.static注意事项

1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。

##41.break ,continue ,return 的区别及作用

break 跳出总上一层循环，不再执行循环(结束当前的循环体)continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)

return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)

##42.在 Java 中，如何跳出当前的多重嵌套循环

可以在**外面的循环语句前定义一个标号**，然后在里层循环体的代码中使用带有**标号的break 语句**，即可跳出外层循环。例如：

```
1 public static void main(String[] args) {
2 ok:
3 for (int i = 0; i < 10; i++) {
4 for (int j = 0; j < 10; j++) {
5 System.out.println("i=" + i + ",j=" + j);
6 if (j == 5) {
7 break ok;
8 }
9
10 }
11 }
12 }
```





##43.静态变量和实例变量区别

静态变量： 静态变量由于**不属于任何实例对象**，属于类的，所以在内存中只会 有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。 

实例变量： 每次创建对象，都会为**每个对象分配成员变量内存空间**，实例变量 是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。

## 44.成员变量与局部变量的区别有哪些 

变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上 讲，变量其实是内存中的一小块区域 

成员变量：方法外部，**类内部定义的变量** 

局部变量：**类的方法中的变量**。 成员变量和局部变量的区别

### 作用域 

成员变量：针对整个类有效。 

局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)

### 存储位置 

成员变量：随着对象的创建而存在，随着对象的消失而消失，**存储在堆内存中**。 

局部变量：在方法被调用，或者语句被执行的时候存在，**存储在栈内存中**。当方法调用完，或者语句结束后，就自动释放。

### 生命周期 

成员变量：随着对象的创建而存在，随着对象的消失而消失 

局部变量：当方法调用完，或者语句结束后，就自动释放。

### 初始值 

成员变量：**有默认初始值。** 

局部变量：没有默认初始值，使用前必须赋值。 

使用原则 

在使用变量时需要遵循的原则为：**就近原则** 首先在局部范围找，有就使用；接着在成员位置找。

##45.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？ 

帮助子类做初始化工作。

## 46.静态方法和实例方法有何不同？

静态方法和实例方法的区别主要体现在两个方面： 

1. 在外部调用静态方法时，可以使用"**类名.方法名"**的方式，也可以使 用"**对象名.方法名**"的方式。而实例方法只有后面这种方式。也就是说，调 用静态方法可以无需创建对象。 

2. 静态方法在访问**本类的成员时**，只允许访问**静态成员**（即静态成员变量 和静态方法），而**不允许访问实例成员变量和实例方法**；

## 47.什么是方法的返回值？返回值的作用是什么？

方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提 是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的 操作！

#内部类

## 48.什么是内部类？

在Java中，可以将**一个类的定义放在另外一个类的定义内部**，这就是内部类。**内部类本身就是类的一个属性**，与其他属性定义方式一致。 

## 49.内部类的分类有哪些 

内部类可以分为四种：

* 成员内部类  ： 成员位置上的非静态类，就是成员内部类。
* 局部内部类 ： 方法中的内部类
* 匿名内部类：　没有名字的内部类
  * 匿名内部类必须**继承一个抽象类或者实现一个接口**。 
  * 匿名内部类不能定义**任何静态成员和静态方法**。 
  * 当所在的方法的**形参**需要被匿名内部类使用时，**必须声明为 final。** 
  * 匿名内部类不能是抽象的，它必须要实现继承的类或者**实现的接口的所有抽象方 法**。
* 静态内部类

## 49.内部类的优点 

我们为什么要使用内部类呢？因为它有以下优点： 

- 一个**内部类可以访问外部类的内容**，包括私有数据！ 
- 内部类**不为同一包的其他类所见，具有很好的封装性**； 

## 50.内部类有哪些应用场景 

1. 解决**一些非面向对象的语句块**。 
2. 当**某个类除了它的外部类，不再被其他的类使用时**。

##51.局部内部类和匿名内部类访问局部变量的时候，为什么变量必须 要加上final？ 

```java
1 public class Outer {
3 	void outMethod(){
4  		final int a =10;
5 			class Inner {
6 				void innerMethod(){
7			 		System.out.println(a);
8 			}
10 	 	 }
11 	}
12 }
```

因为**生命周期不一致**， **局部变量直接存储在栈中**，当方法执行结束后，**非final的局部变量就被销毁**。

**而局部内部类对局部变量的引用依然存在**，如果局部内部类要调用局部变量时，就会**出错。**

final修饰的字段都是编译期常量，常量放在常量池，（方法区的元空间中）

## 52.内部类相关，看程序说出运行结果



##52.什么是异常？

Java异常是Java提供的**一种识别及响应错误的一致性机制**。

异常机制的好处：

* **异常处理代码**和正**常业务代码分离。**

* 并提高程序健壮性
* 回答what, where, why这3个问题

##53.Java中异常分为哪些种类？

### 53.1.Throwable

Throwable 是 Java 语言中所有错误与异常的超类。

Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。

### 53.2. Error（错误）

定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。

特点：此类错误一般表示代码运行时 **JVM 出现问题**。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。

比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，**JVM 将终止线程**。这些错误是不受检异常，非代码性错误。

按照Java惯例，我们是不应该实现任何新的Error子类的！

### 53.3. Exception（异常）

程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。

####运行时异常

特点：**Java 编译器不会检查它**。**没有throws声明也能通过**。

EX: **ArrayIndexOutBoundException**数组下标越界异常、**ClassCastException**类型转换异常、**ArithmeticExecption**算术异常

####编译时异常

特点：java编译器会检查它。必须throws或者catch异常。否则不能通过编译。

**EX：IOException**，**ClassNotFoundException**

![image-20210830164428075](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210830164428075.png)







##54.java8新特性？

### Lambda表达式 

Lambda表达式是Java8所引入的新特性之一，其**基于函数式接口**，**以极大地减少代码冗余，并提高代码的可读性**。

**函数式接口**：仅包含一个抽象方法的接口。

接口上使用**@FunctionalInterface注**解是否是函数式接口。

ex:

```java
@FunctionalInterface
public interface Comparator<T> {
	 int compare(T o1, T o2);
}
```

匿名内部类

```java
//匿名内部类
Arrays.sort(a,new Comparator<Integer>(){
    @Override
   public int compare(Integer o1, Integer o2){
        return o1-o2;
    }
});
//lamada表达式
Arrays.sort(a, (o1, o2) -> o1-o2);
```

##55.Java 8的接口新增了哪些特性？

jdk1.8之前，只能有抽象方法，不能有任何方法的实现（方法体）。

jdk1.8，引⼊了新的关键字default，在接口中**使⽤default修饰的方法**，可以**在接⼝⾥编写方法体。**

```java
public interface Animal {
	
	void eat();
	
	default void sleep() {
		System.out.println("睡觉");
	}
	
}
```

### Stream流	

JDK1.8增强了集合框架，支持了lambda， 流操作。

```java
list.stream()//获取流
    .filter(s -> s.startsWith("张"))
    .filter(s -> s.length() == 3)
    .forEach(System.out::println);//终结方法
```

Stream流的三类方法

+ 获取Stream流
  + 创建一条流水线  **.stream()**
+ 中间方法
  + 流水线上的操作  **filter(0**
+ 终结方法
  + 一个Stream流只能有一个终结方法    .**forEach()**

常见**中间方法**

| 方法名                                          | 说明                                                       |
| ----------------------------------------------- | ---------------------------------------------------------- |
| Stream<T> filter(Predicate predicate)           | 用于对流中的数据进行过滤                                   |
| Stream<T> limit(long maxSize)                   | 返回此流中的元素组成的流，截取前指定参数个数的数据         |
| Stream<T> skip(long n)                          | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流       |
| static <T> Stream<T> concat(Stream a, Stream b) | 合并a和b两个流为一个流                                     |
| Stream<T> distinct()                            | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |

**常见终结方法**

| 方法名                        | 说明                     |
| ----------------------------- | ------------------------ |
| void forEach(Consumer action) | 对此流的每个元素执行操作 |
| long count()                  |                          |

forEach()方法：

底层：循环获取流中的每一个数据，并循环调用accept方法。 

```java

Arrays.stream(a).forEach(new Consumer<Integer>() {
    @Override
    public void accept(Integer integer) {
        System.out.println(integer);
    }
});
Arrays.stream(a).forEach(integer -> System.out.println(integer));
```

#### parallelStream

并行流使用了ForkJoin框架和ForkJoinPool.

### **JVM新特性**

JDK8在JVM中修改重要有：

- 使用metaSpace代替永久区

### **HashMap变化**

JDK8优化了HashMap的实现， 主要优化点包括：

- 将链表方式修改成链表或者红黑树的形式
- 修改resize的过程，解决JDK7在resize在并发场景下死锁的隐患
- JDK1.7存储使用Entry数组， JDK8使用Node或者TreeNode数组存储

当链表长度大于8是链表的存储结构会被修改成红黑树的形式。

查询效率从O(N)提升到O(logN)。链表长度小于6时，红黑树的方式退化成链表。

JDK7链表插入是**从链表头部插入**， 在resize的时候会将原来的**链表逆序**。

JDK8插入从链表**尾部插入**， 因此在resize的时候仍然保持原来的顺序。



## Comparator与Comparable

String实现了Comparable类。

String中的compareTo()方法按照字典序排序：

```java
  str1.compareTo(str2); 
```

### Comparable

Comparable对实现它的每个类的对象进行整体排序

实现 Comparable 接口的类的对象的 List 列表 ( 或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

### Comparator

比较器需要自己写。

compare返回值

负数 ： 需要调整

整数：不需要调整

升序规则：

- o1 > o2，返回正数，**true**，表示需要**调整**顺序，升序。
- o1 < o2，返回负数，**false**，表示**不需要调整**顺序，升序。

降序规则：

- o1 > o2，返回负数，false，表示不需要调整顺序，降序。
- o1 < o2，返回正数，true，表示需要调整顺序，降序。 

不排序规则：

- o1 = o2，返回0，按当前顺序即可，或者比较其他参数。
