# redisobject对象

redis使用对象来表示数据库中的键和值。

当我们set一个键值对时，我们会创建两个redisObject对象

RedisObject的属性：

* 对象的类型
* 编码：
* 指针ptr：指向底层数据结构

```c
typedef struct redisObject {
    unsigned type:4;        // 4 bit
    unsigned encoding:4;    // 4 bit
    unsigned lru:LRU_BITS;  // 24 bit
    int refcount;　　　　　　 // ４字节
    void *ptr;              // 8字节
} robj;
```

redisObject占 ：16字节　＝　32bit(4字节) + ４字节　+ 8字节

一般来说键 == 字符串对象。

encoding：表示对象底层所使用数据结构

![image-20210909202241376](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210909202241376.png)

使用编码的好处：通过encoding属性来设定对象使用编码，而不是对象与底层数据结果关联，提高了redis的灵活性。

ex:

list对象

* 在包含元素少时，使用压缩列表（连续内存来存储，省去链表指针）
* 元素多，使用双端列表

#六种底层数据结构

> https://www.cnblogs.com/ysocean/p/9080940.html

##1.SDS对象

SDS对象，此对象中包含三个属性：

- len    : buf中**已经占有的长度(**表示此字符串的实际长度),不包括\0
- free  : buf中**未使用**的缓冲区长度
- buf[] :  **实际保存字符串数据**的地方

SDS占3字节

```c
struc SDS{
    int8 capacity;  // 1字节
    int8 len;       // 1字节
    int8 flags;     // 1字节
    byte[] content; // 内容
}
```



![img](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/1120165-20180528075607627-218845583.png)

###好处：

###1.常数复杂度获取字符串长度

　　由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C  语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。

###2.杜绝缓冲区溢出

　　我们知道在 C 语言中使用 strcat  函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出

###3减少修改字符串的内存重新分配次数

C语言由于**不记录字符串的长度**，所以如果要修改字符串，必须要重新分配内存（先释放再申请）

因为如果没有重新分配，**字符串长度增大**时会造成**内存缓冲区溢出**，**字符串长度减小**时会造成**内存泄露**(没有立即回收多出来的字节)。

而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：

* **空间预分配**：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。
  * len < 1MB 	buf实际长度：len + len +1byte;
  * len > 1MB    buf实际长度：len + 1MB +1byte;
* **惰性空间释放**：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）

###4.二进制安全

　　因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；

而所有  SDS 的API 都是以**处理二进制的方式**来处理 buf 里面的元素，**SDS** 不是**以空字符串**来判断是否**结束**，而是**以 len  属性表示的长度来判断字符串是否结束。**

###5.兼容部分 C 字符串函数

　　虽然 SDS 是二进制安全的，但是一样**遵从每个字符串都是以空字符串结尾的惯例**，这样可以重用 C 语言库<string.h> 中的一部分函数。

## 2.链表

List的6个属性：

* 1.头指针 head
* 2.尾指针 tail
* 3.节点长度 len
* 4.复制函数 dup()
* 5.释放函数 free()
* 6.比对函数 match()

ListNode底层是一个**双向无环链表**。

## 3.字典

字典又称为映射（map），是一种用于**保存键值对的抽象数据结构**。字典中的**每一个键 key 都是唯一的**，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。

### 属性

dictht

* 哈希数组
* 哈希表大小 size
* 哈希表大小掩码，用于计算索引值：sizemask = size - 1
* 已有节点数量  used

dictEntry

* key
* 值{val ,}
* 下一个哈希表节点: next 

### 哈希算法

计算hash后 & 上数组长度- 1

index = hash & dict -> ht[X].sizemask 

解决冲突链地址法

###rehash扩容和收缩：

　　　　　　1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。

　　　　　　2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。

　　　　　　3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。

#####触发扩容的条件：

　　　　　　1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。

　　　　　　2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。

　　　　ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。

###渐近式 rehash

渐进式  rehash：扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。

如果键值对有几百万，几千万甚至几亿，那么要一次性的进行  rehash，势必会造成Redis一段时间内不能进行别的操作。

所以Redis采用渐进式  rehash,这样在进行渐进式rehash期间，

字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。

但是进行 增加操作，一定是在新的哈希表上进行的。

## 4.跳跃表

　跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：

将有序链表改造为**支持“折半查找”算法**，可以**快速的插入，删除，查找操作。**

查找时间复杂度：O(logn)

## 5.整数集合

　　整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。

　　length 属性记录了 contents 数组的大小。

　　需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。

###5.1升级

当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：

　　1、根据新**元素类型，扩展整数集合底层数组的大小，并为新元素分配空间**。

　　2、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。

　　3、将**新元素添加到整数集合中（保证有序）。**

　**升级能极大地节省内存。**

###5.2降级

　　整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

## 6.压缩列表

　压缩列表（ziplist）是Redis为了节省内存而开发的，是由**一系列特殊编码**的**连续内存块组成的顺序型数据结构**。

一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个**字节数组**或者**一个整数值。**

压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是**将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。**



#5种对象的实现

![image-20210909211003584](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/image-20210909211003584.png)

## 1.String

encoding: 

* int：能转整数
* raw :  小于等于44字节
* embstr：大于44字节

### 为什么是44字节？

64 - **16(redisObject头部) - 3(SDS头) -1("\0")** = 44

![img](https://ljjblog.oss-cn-beijing.aliyuncs.com/img/406456-20191201001855305-1852600125.png)

> https://www.cnblogs.com/sunchong/p/11924295.html



## 2.Hash

encoding：

* 哈希表(字典)

* 压缩列表(ziplist)：所有键值**数量小于64，长度小于512**

###编码转换

满足下面两个转换成ziplist

* hash对象包含的所有键值对的**键和值长度 都小于 64字节**

* 哈希对象保存的**键值对数量小于512个。**

##3.List

encoding:

* ziplist
* 双向链表

###编码转换

满足下面两个转换成ziplist

* 列表对象保存的所有 **字符串长度都小于 64字节**

* 列表对象保存的**元素数量小于512个。**

## 4.Set

* **整数集合(intSet)**:  

* **哈希表(hashtable)**：

哈希表存储时，值value ==null。

###编码转换

满足下面两个转换成**整数集合(intSet)**

* 集合对象保存**所有元素都是整数值**

* 列表对象保存的**元素数量小于512个。**

## 5.Zset

* **压缩列表(ziplist)**

* **跳表(skiplist)** + hash表

###编码转换

使用压缩列表？

* 所有元素**成员长度小于64字节**
* 有序集合的**元素数量小于128**

###为什么有序集合zset需要同时使用跳跃表和字典来实现？

1. 使用范围查询zrange和zrank时，使用跳跃表
2. 使用查找时，使用哈希表